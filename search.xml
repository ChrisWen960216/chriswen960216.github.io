<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于我</title>
    <url>/2020/10/14/about-me/</url>
    <content><![CDATA[<center>

<p>悲伤或许有</p>
<p>痛苦或许很多</p>
<p>但是我想</p>
<p>还有很多梦想未醒</p>
<p>世界很大</p>
<p>风住过这里</p>
</center>




]]></content>
      <categories>
        <category>他说</category>
      </categories>
      <tags>
        <tag>他说</tag>
        <tag>关于我</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2020/10/15/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<blockquote>
<p>学习算法和数据结构时，对于二叉树的一些总结</p>
</blockquote>
<a id="more"></a>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>二叉树是一个联通的无环图，有了根节点之后，每个顶点定义了唯一的父节点，和最多两个子节点。并且严格区分左子树，右子树，子树是有序不可颠倒的。</p>
<h2 id="具象化"><a href="#具象化" class="headerlink" title="具象化"></a>具象化</h2><p>二叉树的每一个节点由熟悉的<code>JavaScript</code>来进行构造，就会是如下方式:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value = null, left = null, right = null) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.left = left;</span><br><span class="line">    <span class="built_in">this</span>.right = right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下的一棵二叉树:<br><img src='/images/tree.png' alt='sample_binary_tree'></p>
<p>如果用<code>JavaScript</code>彻底展开构造的话，会是这个样子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  value: <span class="number">3</span>,</span><br><span class="line">  left: &#123;</span><br><span class="line">    value: <span class="number">9</span>,</span><br><span class="line">    left: <span class="literal">null</span>,</span><br><span class="line">    right: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  right: &#123;</span><br><span class="line">    value: <span class="number">20</span>,</span><br><span class="line">    left: &#123;</span><br><span class="line">      value: <span class="number">15</span>,</span><br><span class="line">      left: <span class="literal">null</span>,</span><br><span class="line">      right: <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    right: &#123;</span><br><span class="line">      value: <span class="number">7</span>,</span><br><span class="line">      left: <span class="literal">null</span>,</span><br><span class="line">      right: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说对二叉树进行操作时，不会将一整棵树的结构全部写出。通常采用一定的顺序对树的节点进行操作，而二叉树的重点也在于此。</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>遍历就是按照一定的顺序浏览一棵树的每一个节点，一般来说遍历有三种方式：</p>
<ol>
<li>前序遍历：先访问当前节点，再访问左节点，再访问右节点</li>
<li>中序遍历：先访问左节点，再访问当前节点，再访问右节点</li>
<li>后序遍历：先访问左节点，再访问右节点，再访问当前节点</li>
</ol>
<p>用代码来解释的话是如下方式:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">travelNode</span>(<span class="params">node, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 前序: callback(node);</span></span><br><span class="line">  travelNode(node.left);</span><br><span class="line">  <span class="comment">// 中序: callback(node);</span></span><br><span class="line">  travelNode(node.right);</span><br><span class="line">  <span class="comment">// 后序: callback(node);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><p>二叉树的核心就是遍历方法，使用遍历几乎可以搞定二叉树的所有问题。</p>
<ol>
<li><p>二叉树的深度：二叉树的深度等于于它最长路径（根-叶子）的长度。只需要通过<code>遍历</code>求得所有路径长度再取最大值即可。这是 <a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">LeetCode 原题: 二叉树的深度 </a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxDepth</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  travelNode(root, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">travelNode</span>(<span class="params">node, depth</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node.left &amp;&amp; !node.right) &#123;</span><br><span class="line">      result = <span class="built_in">Math</span>.max(result, depth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.left) &#123;</span><br><span class="line">      travelNode(node.left, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.right) &#123;</span><br><span class="line">      travelNode(node.right, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并两棵二叉树：通过<code>遍历</code>获得两棵二叉树的节点值，将目标树合并到根数上即可。这是<a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">LeetCode 原题：合并二叉树</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeTrees</span>(<span class="params">t1, t2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!t2) &#123;</span><br><span class="line">    <span class="keyword">return</span> t1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!t1) &#123;</span><br><span class="line">    <span class="keyword">return</span> t2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  t2.val = t2.val + t1.val;</span><br><span class="line">  t2.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">  t2.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">  <span class="keyword">return</span> t2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">travelNode</span>(<span class="params">node, root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node.left &amp;&amp; !node.right) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node.left) &#123;</span><br><span class="line">    root.left</span><br><span class="line">      ? (root.left.val = root.left.val + node.left.val)</span><br><span class="line">      : (root.left = <span class="keyword">new</span> TreeNode(node.left.val));</span><br><span class="line">    travelNode(node.left, root.left);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node.right) &#123;</span><br><span class="line">    root.right</span><br><span class="line">      ? (root.right.val = root.right.val + node.right.val)</span><br><span class="line">      : (root.right = <span class="keyword">new</span> TreeNode(node.right.val));</span><br><span class="line">    travelNode(node.right, root.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>树的遍历无非就是<code>迭代</code>和<code>递归</code>。三种常见的遍历方式的区别取决于何时处理当前节点。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>开篇</title>
    <url>/2020/09/21/%E5%BC%80%E7%AF%87/</url>
    <content><![CDATA[<img src='/images/rain.png'>

<center>

<p>我有一些故事</p>
<p>让他们就这么老去 有些不妥</p>
<p>在这个落雨的夜晚</p>
<p>我把他们都讲给你听</p>
</center>
]]></content>
      <categories>
        <category>他说</category>
      </categories>
      <tags>
        <tag>他说</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的前序遍历</title>
    <url>/2020/10/27/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<blockquote>
<p>Leetcode 每日一题 - 144. 二叉树的前序遍历 思路</p>
</blockquote>
<a id="more"></a>

<h2 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h2><p>给定一个二叉树，返回前序遍历。</p>
<p>特别的: 通过迭代而不是递归完成</p>
<h2 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h2><p>我认为二叉树的遍历就如同数学公式，前中后序遍历相差无几，递归的算法极其简单:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">travelNode</span>(<span class="params">node, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 前序: callback(node);</span></span><br><span class="line">  travelNode(node.left);</span><br><span class="line">  <span class="comment">// 中序: callback(node);</span></span><br><span class="line">  travelNode(node.right);</span><br><span class="line">  <span class="comment">// 后序: callback(node);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="迭代算法"><a href="#迭代算法" class="headerlink" title="迭代算法"></a>迭代算法</h2><p>迭代和递归的区别在于一个是循环，一个是调用本身。</p>
<p>同时，递归始终可以改成迭代。并且递归是通过调用栈层层调用，即将调用的所有函数全部压入调用栈然后再挨个弹出执行，可能会导致<code>栈溢出</code>的问题。而迭代则是占用事件队列，当当前事件完成后立刻进行下一次的执行，不会造成<code>栈溢出</code>的问题。</p>
<p>再重复一遍: <code>递归始终可以改成迭代/循环</code>。</p>
<p>本题思路:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">preorderTraversal</span> (<span class="params">root</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">if</span>(!root)&#123; <span class="keyword">return</span> result; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> stack = [root];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过栈来将递归改成循环</span></span><br><span class="line">    <span class="keyword">while</span>(stack.length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">const</span> current = stack.pop();</span><br><span class="line">      </span><br><span class="line">      result.push(current.val);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(current.right)&#123;</span><br><span class="line">        stack.push(current.right);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(current.left)&#123;</span><br><span class="line">        stack.push(current.left);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>固定团智能计划V1.0发布</title>
    <url>/2020/10/28/%E5%9B%BA%E5%AE%9A%E5%9B%A2%E6%99%BA%E8%83%BD%E8%AE%A1%E5%88%92V1-0%E5%8F%91%E5%B8%83/</url>
    <content><![CDATA[<blockquote>
<p>隆重为你介绍 固定团智能计划V1.0 版本</p>
</blockquote>
<a id="more"></a>

<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li><p>各位团长可以创建自定义团队排表，并发给团员，团员通过团队ID/登记链接进行自己的团队登记，从而方便管理每一车副本的人员信息。</p>
</li>
<li><p>团队的每一位角色都可以被团长/团员定制，包括门派、游戏角色ID和使用本号打本的团员ID，三者之间没有耦合，方便满足 专职叫老板登/专职上号打本 等各种角色的团员登记。</p>
</li>
</ul>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li><p>免费！</p>
</li>
<li><p>简单的操作流程，你甚至都不用登录，更不需要注册。对懒人极其友好。</p>
</li>
<li><p>高度的自定义团队每一位成员，包括门派、游戏角色ID和上号团员的ID。亦或者什么都不设置，一键创建团队排表。</p>
</li>
<li><p>不要求登记任何账号密码，亦不要求绑定任何角色，个人 游戏/三次元 信息安全无忧。</p>
</li>
<li><p>无需手动输入 团队/个人ID，点击即可复制粘贴，解放双手。</p>
</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul>
<li><p>微信搜索: <code>固定团智能计划</code></p>
</li>
<li><p>QQ搜索: <code>开团小助手</code></p>
</li>
<li><p>直接用微信扫描该二维码直接打开.</p>
</li>
</ul>
<img src='/images/ga/qrcode.jpg' />

<h2 id="使用截图"><a href="#使用截图" class="headerlink" title="使用截图"></a>使用截图</h2><ul>
<li>首页</li>
</ul>
<img src='/images/ga/main.png' />

<ul>
<li>个人<ul>
<li>点击左上角个人头像,会复制个人ID到剪贴板，方便我们追踪您的数据问题。</li>
<li>点击右上角的胶囊按钮，可以分享该小程序到对应的QQ/微信。</li>
</ul>
</li>
</ul>
<img src='/images/ga/user.png' />

<ul>
<li>创建团队</li>
</ul>
<img src='/images/ga/create.png' />

<ul>
<li>登记团队<ul>
<li>点击右上角的胶囊按钮，可以分享该小程序到对应的QQ/微信。</li>
</ul>
</li>
</ul>
<img src='/images/ga/add.png' />

<ul>
<li>分享<ul>
<li>可以直接将团队登记面板通过微信发送给团队成员，点击链接直接登记信息</li>
</ul>
</li>
</ul>
<img src='/images/ga/share.png'>

<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul>
<li>因为平台受限，QQ小程序和微信小程序数据不互通。为了保持一致以及后续的迭代，请各位团长最好专一的使用其中的一个。</li>
<li>不论是QQ还是微信小程序，功能总是会同步更新（平台审核速度的可能会影响更新的速度，但是绝大多数情况下会在同一天提交给腾讯进行审核）</li>
</ul>
<h2 id="联系作者"><a href="#联系作者" class="headerlink" title="联系作者"></a>联系作者</h2><ul>
<li>QQ：957638221</li>
<li>微信: Wen_Christian</li>
</ul>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p><input type='checkbox' /> 团队人员出勤统计<br><input type='checkbox' /> 模板云端保存<br><input type='checkbox' /> 新的团队管理模式<br><input type='checkbox' /> 团长权限分享<br><input type='checkbox' /> 一键报名/取消</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>技术</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
</search>
