<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于我</title>
    <url>/2020/10/14/about-me/</url>
    <content><![CDATA[<center>

<p>悲伤或许有</p>
<p>痛苦或许很多</p>
<p>但是我想</p>
<p>还有很多梦想未醒</p>
<p>世界很大</p>
<p>风住过这里</p>
</center>




]]></content>
      <categories>
        <category>他说</category>
      </categories>
      <tags>
        <tag>他说</tag>
        <tag>关于我</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2020/10/15/%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<blockquote>
<p>学习算法和数据结构时，对于二叉树的一些总结</p>
</blockquote>
<a id="more"></a>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>二叉树是一个联通的无环图，有了根节点之后，每个顶点定义了唯一的父节点，和最多两个子节点。并且严格区分左子树，右子树，子树是有序不可颠倒的。</p>
<h2 id="具象化"><a href="#具象化" class="headerlink" title="具象化"></a>具象化</h2><p>二叉树的每一个节点由熟悉的<code>JavaScript</code>来进行构造，就会是如下方式:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value = null, left = null, right = null) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">    <span class="built_in">this</span>.left = left;</span><br><span class="line">    <span class="built_in">this</span>.right = right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下的一棵二叉树:<br><img src='/images/tree.png' alt='sample_binary_tree'></p>
<p>如果用<code>JavaScript</code>彻底展开构造的话，会是这个样子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  value: <span class="number">3</span>,</span><br><span class="line">  left: &#123;</span><br><span class="line">    value: <span class="number">9</span>,</span><br><span class="line">    left: <span class="literal">null</span>,</span><br><span class="line">    right: <span class="literal">null</span></span><br><span class="line">  &#125;,</span><br><span class="line">  right: &#123;</span><br><span class="line">    value: <span class="number">20</span>,</span><br><span class="line">    left: &#123;</span><br><span class="line">      value: <span class="number">15</span>,</span><br><span class="line">      left: <span class="literal">null</span>,</span><br><span class="line">      right: <span class="literal">null</span></span><br><span class="line">    &#125;,</span><br><span class="line">    right: &#123;</span><br><span class="line">      value: <span class="number">7</span>,</span><br><span class="line">      left: <span class="literal">null</span>,</span><br><span class="line">      right: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说对二叉树进行操作时，不会将一整棵树的结构全部写出。通常采用一定的顺序对树的节点进行操作，而二叉树的重点也在于此。</p>
<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>遍历就是按照一定的顺序浏览一棵树的每一个节点，一般来说遍历有三种方式：</p>
<ol>
<li>前序遍历：先访问当前节点，再访问左节点，再访问右节点</li>
<li>中序遍历：先访问左节点，再访问当前节点，再访问右节点</li>
<li>后序遍历：先访问左节点，再访问右节点，再访问当前节点</li>
</ol>
<p>用代码来解释的话是如下方式:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">travelNode</span>(<span class="params">node, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 前序: callback(node);</span></span><br><span class="line">  travelNode(node.left);</span><br><span class="line">  <span class="comment">// 中序: callback(node);</span></span><br><span class="line">  travelNode(node.right);</span><br><span class="line">  <span class="comment">// 后序: callback(node);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><p>二叉树的核心就是遍历方法，使用遍历几乎可以搞定二叉树的所有问题。</p>
<ol>
<li><p>二叉树的深度：二叉树的深度等于于它最长路径（根-叶子）的长度。只需要通过<code>遍历</code>求得所有路径长度再取最大值即可。这是 <a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/">LeetCode 原题: 二叉树的深度 </a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxDepth</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  travelNode(root, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">travelNode</span>(<span class="params">node, depth</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node.left &amp;&amp; !node.right) &#123;</span><br><span class="line">      result = <span class="built_in">Math</span>.max(result, depth);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.left) &#123;</span><br><span class="line">      travelNode(node.left, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (node.right) &#123;</span><br><span class="line">      travelNode(node.right, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并两棵二叉树：通过<code>遍历</code>获得两棵二叉树的节点值，将目标树合并到根数上即可。这是<a href="https://leetcode-cn.com/problems/merge-two-binary-trees/">LeetCode 原题：合并二叉树</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeTrees</span>(<span class="params">t1, t2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!t2) &#123;</span><br><span class="line">    <span class="keyword">return</span> t1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!t1) &#123;</span><br><span class="line">    <span class="keyword">return</span> t2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  t2.val = t2.val + t1.val;</span><br><span class="line">  t2.left = mergeTrees(t1.left, t2.left);</span><br><span class="line">  t2.right = mergeTrees(t1.right, t2.right);</span><br><span class="line">  <span class="keyword">return</span> t2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">travelNode</span>(<span class="params">node, root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!node.left &amp;&amp; !node.right) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node.left) &#123;</span><br><span class="line">    root.left</span><br><span class="line">      ? (root.left.val = root.left.val + node.left.val)</span><br><span class="line">      : (root.left = <span class="keyword">new</span> TreeNode(node.left.val));</span><br><span class="line">    travelNode(node.left, root.left);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (node.right) &#123;</span><br><span class="line">    root.right</span><br><span class="line">      ? (root.right.val = root.right.val + node.right.val)</span><br><span class="line">      : (root.right = <span class="keyword">new</span> TreeNode(node.right.val));</span><br><span class="line">    travelNode(node.right, root.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>树的遍历无非就是<code>迭代</code>和<code>递归</code>。三种常见的遍历方式的区别取决于何时处理当前节点。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>开篇</title>
    <url>/2020/09/21/%E5%BC%80%E7%AF%87/</url>
    <content><![CDATA[<img src='/images/rain.png'>

<center>

<p>我有一些故事</p>
<p>让他们就这么老去 有些不妥</p>
<p>在这个落雨的夜晚</p>
<p>我把他们都讲给你听</p>
</center>
]]></content>
      <categories>
        <category>他说</category>
      </categories>
      <tags>
        <tag>他说</tag>
      </tags>
  </entry>
</search>
